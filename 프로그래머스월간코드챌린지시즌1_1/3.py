# AC
# 배열이 주어질때, 인접한 임의의 두 수를 선택할 수 있고
# 선택한 수끼리 싸워 한 수를 없앨 수 있는 문제
# 항상 큰 수가 싸움에서 져서, 큰수는 사라진다
# 하지만 한 배열이 주어졌을때 딱 한번, 큰수가 작은수를 이겨서 없앨 수 있다

# 배열에 주어진 수 중, 
# 어떤 한 수에 대해서 그 수만 혼자 남는 방법이 한가지라도 있을 수 있고, 아예 없을 수도 있다
# 한가지라도 있는 수들의 개수를 구하는 문제

# 1. 풀이 방법을 생각하기 어려웠음
# 2. 시간 초과를 해결하기 위한 방법을 찾기 어려웠음

def solution(a):
    answer = 0
    if len(a) == 1:
        return 1
    if len(a) == 2:
        return 2

    # 양쪽 모두에, 자기 자신보다 작은 수가 
    # 1개 이상이라도 있으면, 그 수는 혼자 남을 수 없음
    # 따라서, 양 끝 수는 반드시 가능
    answer = 2

    # 전처리
    # 앞에서 뒤로, 0~i-1 까지 최소값이 i번째 수보다 작다면
    # i의 앞쪽에는 i보다 작은 수가 최소 1개이상 있다
    cache = [0] * len(a)
    min = a[0]
    for i in range(1, len(a)):
        if a[i] > min:
            cache[i] += 1
        else:
            min = a[i]
    # 뒤에서 앞으로, i+1~n 까지 최소값이 i 번째 수보다 작다면
    # i의 뒤쪽에는 i보다 작은 수가 최소 1개이상 있다
    min = a[-1]
    for i in range(2,len(a)+1):
        if a[-i] > min:
            cache[-i] += 1
        else:
            min = a[-i]


    # i의 앞과 뒤, 즉 양 쪽에 a[i]보다 작은 수가 최소 1개 이상 있는 경우(cache==2)
    # 그 수는 혼자 남을 수 없다
    for i in range(1, len(a)-1):
        if cache[i] != 2:
            answer += 1

    return answer

print(
solution([-16,27,65,-2,58,-92,-71,-68,-61,-33])
)