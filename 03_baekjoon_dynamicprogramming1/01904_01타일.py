import sys

'''
					0
		  	1  				2
		2   	3 		 3		!4
	  3	  *4  *4 5	   !4  5   5  6
	*4 5 . . . . . . . . . . .........
'''
# 타일을 고를때마다 1 또는 2를 (두가지 선택지) 선택하여 
# 선택한 수들의 합이 N이 되는 경우의 수를 찾는다.
# N까지 그린 2진트리의 단말노드 개수가 정답

'''N이 증가하면서 아래를 반복한다'''
# 각 N에 대하여 값N을 가지는 노드는 단말노드이다
# ( 자식이 없다 ) (N이 1 증가하면 왼쪽 자식을 가지게 된다.)

# 각 N에 대하여 값 N-1을 가지는 노드들은 오른쪽 자식이 없다.
# (왼쪽 자식이 N이다) (N이 1 증가하면 오른쪽 자식을 가지게 된다.)

# N=1, 1
'''
					0
		  	1.
'''
# N=2, 2
'''
					0
		  	1  				.2
		2.
'''
# N=3, 3
'''
					0
		  	1  				2
		2     .3 		  3.		
	  3.
'''
# N=4, 5, 이전 그래프에의 3노드의 왼쪽 자식,  2노드의 오른쪽 자식이 4노드가 된다
'''
					0
		  	1  				2
		2   	3 		 3		.4
	  3	 .4   4.       4.  
	4.  
'''
# 피보나치 수열이라는 것을 알 수 있다.

N = (int)(input())

# [0]은 사용 안함
cache = [-1 for _ in range(0,1000001)]
cache[1] = 1
cache[2] = 2
cache[3] = 3

# 재귀 호출 방법은 너무 깊이 들어가서 안됨
# N<=1000,000
def fibo(n):
	ret = cache[n]
	if ret != -1:
		return ret
	
	ret = fibo(n-1) + fibo(n-2)
	cache[n] = ret
	return ret

def fibo2(n):
	if N<=3:
		return n
	
	for i in range(4,n+1):
		cache[i] = (cache[i-1] + cache[i-2]) % 15746
	
	return cache[n]

print(fibo2(N))