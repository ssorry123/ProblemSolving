''' 대회 당시 AC '''
# 배열이 주어질때, 인접한 임의의 두 수를 선택할 수 있고
# 선택한 수끼리 싸워 한 수를 없앨 수 있는 문제
# 항상 큰 수가 싸움에서 져서, 큰수는 사라진다
# 하지만 한 배열이 주어졌을때 딱 한번, 큰수가 작은수를 이겨서 없앨 수 있다

# 배열에 주어진 수 중, 
# 어떤 한 수에 대해서 그 수만 혼자 남는 방법이 한가지라도 있을 수 있고, 아예 없을 수도 있다
# 한가지라도 있는 수들의 개수를 구하는 문제
# 큰 수가 작은 수를 이기는 경우가 없다면, 결과는 항상 제일 작은 수가 홀로 남는다

# 1. 풀이 방법을 생각하기 어려웠음
# 2. 시간 초과를 해결하기 위한 방법을 찾기 어려웠음

def solution(a):
    answer = 0
    if len(a) == 1:
        return 1
    if len(a) == 2:
        return 2

    # 양끝에 있는 수는 자신의 왼쪽 또는 오른쪽에
    # 작은 수가 오든 큰 수가 오든 이길 수 있으므로 항상 가능한 방법이 있음
    answer = 2

    # 전처리
    # 앞에서 뒤로, 0~i-1 까지 최소값이 i번째 수보다 작다면
    # i번째 수는 왼쪽에 위치한 최소값을 제거해야 살아남을 수 있음
    cache = [0] * len(a)
    min = a[0]
    for i in range(1, len(a)):
        if a[i] > min:
            cache[i] += 1
        else:
            min = a[i]
    # 뒤에서 앞으로, i+1~n 까지 최소값이 i 번째 수보다 작다면
    # i번째 수는 오른쪽에 위치한 최소값을 제거해야 살아남을 수 있음
    min = a[-1]
    for i in range(2,len(a)+1):
        if a[-i] > min:
            cache[-i] += 1
        else:
            min = a[-i]


    # i의 앞과 뒤, 즉 양 쪽에 a[i]보다 작은 값이 최종적으로 남는 경우
    # (a[i]가 작은 수를 이기는 방법을 두번 써야하는 경우)
    # a[i] 는 살아남을 수 없다
    for i in range(1, len(a)-1):
        if cache[i] != 2:
            answer += 1

    return answer

print(
solution([-16,27,65,-2,58,-92,-71,-68,-61,-33])
)